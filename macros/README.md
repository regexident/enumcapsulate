# `enumcapsulate-macros`

[![Crates.io](https://img.shields.io/crates/v/enumcapsulate-macros)](https://crates.io/crates/enumcapsulate-macros)
[![Crates.io](https://img.shields.io/crates/d/enumcapsulate-macros)](https://crates.io/crates/enumcapsulate-macros)
[![Crates.io](https://img.shields.io/crates/l/enumcapsulate-macros)](https://crates.io/crates/enumcapsulate-macros)
[![docs.rs](https://docs.rs/enumcapsulate-macros/badge.svg)](https://docs.rs/enumcapsulate-macros/)

Derive macros for [enumcapsulate](https://crates.io/crates/enumcapsulate) crate.

----

## Macros

The `enumcapsulate-macros` proc-macro crate exports the following derive macros:

| Derive macro          | Functionality                                                                                |
| --------------------- | -------------------------------------------------------------------------------------------- |
| `FromVariant`         | Derives impls for `Self: enumcapsulate::FromVariant<T>` for each non-unit variant type `T`.  |
| `IntoVariant`         | Derives impls for `Self: enumcapsulate::FromVariant<T>` for each non-unit variant type `T`.  |
| `From`                | Derives impls for `Self: core::convert::From<T>` for each non-unit variant type `T`.         |
| `TryInto`             | Derives impls for `T: core::convert::TryFrom<Self>` for each non-unit variant type `T`.      |
| `AsVariant`           | Derives impls for `Self: enumcapsulate::AsVariant<T>` for each non-unit variant type `T`.    |
| `AsVariantMut`        | Derives impls for `Self: enumcapsulate::AsVariantMut<T>` for each non-unit variant type `T`. |
| `AsVariantRef`        | Derives impls for `Self: enumcapsulate::AsVariantRef<T>` for each non-unit variant type `T`. |
| `IsVariant`           | Derives impl for `enumcapsulate::IsVariant`.                                                 |
| `VariantDiscriminant` | Derives impl for `Self: enumcapsulate::VariantDiscriminant`.                                 |

… as well as an umbrella derive macro `Encapsulate`.

> [!NOTE]
> The implementations generated by the `From` and `FromVariant`, as well as the `TryInto` and `IntoVariant` derive macro pairs are semantically equivalent.

### `#[derive(Encapsulate)]`

The umbrella derive macro `Encapsulate` allows for conveniently deriving `AsVariant`, `AsVariantMut`, `AsVariantRef`, `From`, `FromVariant`, `IntoVariant`, `IsVariant`, `TryInto`, `VariantDiscriminant`, and `VariantDowncast` all at once.

The following two snippets are semantically equivalent:

```rust
#[derive(Encapsulate)]
enum Enum { /* ... */ }
```

```rust
#[derive(
    FromVariant,
    IntoVariant,
    From,
    TryInto,
    AsVariant,
    AsVariantMut,
    AsVariantRef,
    IsVariant,
    VariantDiscriminant,
)]
enum Enum { /* ... */ }
```

> [!TIP]
> If the list of trait derives produced by `#[derive(Encapsulate)]` is too broad of a stroke
> your your particular use case then your can selectively opt them out by use of an
> `#[enumcapsulate(exclude(…))]` attribute on the enum itself.
>
> You can even opt trait derives back in at the variant-level, by use of `#[enumcapsulate(include)]`
> for previously opted-out derives, or individually by use of `#[enumcapsulate(include(…))]`:
>
> ```rust
> #[derive(Encapsulate)]
> #[enumcapsulate(exclude(From, TryInto))]
> enum Enum {
>     // Excluded from `From` and `TryInto` derives
>     // due to existing enum-level attribute:
>     VariantA(VariantA),
>
>     // Selectively re-included for all derives:
>     #[enumcapsulate(include)]
>     VariantB(VariantB),
>
>     // Selectively re-included for `From` derive:
>     #[enumcapsulate(include(From))]
>     VariantC(VariantC),
> }
> ```

### `#[derive(AsVariant)]`

The `AsVariant` derive macro requires the variant's field type to implement `Clone`.

## Macro helper attributes

Most of the derive macros support helper attributes:

### Enum attributes

#### `#[enumcapsulate(exclude(…))]`

Exclude this variant from trait derivation.

- `#[enumcapsulate(exclude(…))]`

    Exclude variant from specific `enumcapsulate` derive macros.

If you wish to opt out of a select few of `Encapsulate`'s trait derives,
then you can do so by use of an `#[enumcapsulate(exclude(…))]` attribute:

```rust
#[derive(Encapsulate)]
#[enumcapsulate(exclude(From, TryInto))]
enum Enum { /* ... */ }
```

> [!TIP]
> If you wish to opt all but a select few variants out of a trait's derive, then
> you can do so by use of an `#[enumcapsulate(exclude(…))]` attribute on the enum,
> together with a `#[enumcapsulate(include(…))]` attribute on the variant:
>
> ```rust
> #[derive(Encapsulate)]
> #[enumcapsulate(exclude(From, TryInto))]
> enum Enum {
>     // Excluded from `From` and `TryInto` derives
>     // due to existing enum-level attribute:
>     VariantA(VariantA),
>
>     // Selectively re-included for all derives:
>     #[enumcapsulate(include)]
>     VariantB(VariantB),
>
>     // Selectively re-included for
>     // just the `From` derive:
>     #[enumcapsulate(include(From))]
>     VariantC(VariantC),
>
>     // ...
> }
> ```

### Variant attributes

> [!NOTE]
> Variant-level attributes have a higher precedence than their equivalent enum-level attributes
> and thus act as a selective override if both are present.

#### `#[enumcapsulate(exclude(…))]`

Exclude this variant from trait derivation.

- `#[enumcapsulate(exclude)]`

    Exclude variant from *all* `enumcapsulate` derive macros.

- `#[enumcapsulate(exclude(…))]`

    Exclude variant from specific `enumcapsulate` derive macros.

```rust
#[derive(Encapsulate)]
enum Enum {
    // Included by default.
    VariantA(VariantA),
    
    // Excluded from all derives:
    #[enumcapsulate(exclude)]
    VariantB(VariantB),
    
    // Excluded from just the `From` and `TryInto` derives:
    #[enumcapsulate(exclude(From, TryInto))]
    VariantC(VariantC),
}
```

> [!TIP]
> Combine the use of `#[enumcapsulate(exclude)]` with `#[enumcapsulate(include(…)]`
> in order to exclude a variant from all but a select few derive macros.
>
> ```rust
> // Exclude variant from all derives,
> // then selectively re-include it for
> // just the `From` and `TryInto` derives:
> #[enumcapsulate(exclude)]
> #[enumcapsulate(include(From, TryInto))]
> ```

This attribute is recognized by the following variant-based derive macros:

- `AsVariant`
- `AsVariantMut`
- `AsVariantRef`
- `FromVariant`
- `IntoVariant`
- `From`
- `TryInto`

… as well as the umbrella derive macro:

- `Encapsulate`

#### `#[enumcapsulate(include(…)]`

Include this variant for specific trait derivation (overriding existing uses of `#[enumcapsulate(exclude)]`).

- `#[enumcapsulate(include)]`

    Include variant from *all* `enumcapsulate` derive macros.

- `#[enumcapsulate(include(…))]`

    Include variant from specific `enumcapsulate` derive macros.

```rust
#[derive(Encapsulate)]
#[enumcapsulate(exclude(From, TryInto))]
enum Enum {
    // Included by default.
    VariantA(VariantA),
    
    // Selectively included for just
    // the `From` and `TryInto` derives:
    #[enumcapsulate(exclude)]
    #[enumcapsulate(include(From, TryInto))]
    VariantB(VariantB),
}
```

> [!NOTE]
> The `#[enumcapsulate(include(…)]` variant has a higher precedence than `#[enumcapsulate(exclude)]`,
> and thus acts as a selective override if both are present on a variant:
>
> ```rust
> // Exclude variant from all derives,
> // then selectively re-include it for
> // just the `From` and `TryInto` derives:
> #[enumcapsulate(exclude)]
> #[enumcapsulate(include(From, TryInto))]
> ```

This attribute is recognized by the following variant-based derive macros:

- `AsVariant`
- `AsVariantMut`
- `AsVariantRef`
- `FromVariant`
- `IntoVariant`
- `From`
- `TryInto`

… as well as the umbrella derive macro:

- `Encapsulate`

#### `#[enumcapsulate(field(… = …)]`

Select a specific variant field as target for trait derivation.

- `#[enumcapsulate(field(index = <index>))]`

    Select field at index `<index>` to be used as target.

- `#[enumcapsulate(field(name = "<name>"))]`

    Select field with name `<name>` to be used as target.

```rust
#[derive(Encapsulate)]
enum Enum {
    // Select field `1`, i.e. `VariantA`:
    #[enumcapsulate(field(index = 1))]
    VariantA(i32, VariantA),
    
    // Select field `b`, i.e. `VariantB`:
    #[enumcapsulate(field(name = "b"))]
    VariantB { b: VariantB, c: u32 },
}
```

> [!NOTE]
> When deriving traits for variants with multiple fields a field
> has to be explicitly specified using `#[enumcapsulate(field(… = …))]`.
>
> Alternatively the variant can be excluded via `#[enumcapsulate(exclude)]`.

This attribute is recognized by the following variant-based derive macros:

- `AsVariant`
- `AsVariantMut`
- `AsVariantRef`
- `FromVariant`
- `IntoVariant`
- `From`
- `TryInto`

… as well as the umbrella derive macro:

- `Encapsulate`

## Documentation

Please refer to the documentation on [docs.rs](https://docs.rs/enumcapsulate-macros).

## Contributing

Please read [CONTRIBUTING.md](CONTRIBUTING.md) for details on our [code of conduct](https://www.rust-lang.org/conduct.html),  
and the process for submitting pull requests to us.

## Versioning

We use [SemVer](http://semver.org/) for versioning. For the versions available, see the [tags on this repository](https://github.com/regexident/enumcapsulate-macros/tags).

## License

This project is licensed under the [**MPL-2.0**](https://www.tldrlegal.com/l/mpl-2.0) – see the [LICENSE.md](LICENSE.md) file for details.
